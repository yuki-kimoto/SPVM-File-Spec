class File::Spec::Win32 extends File::Spec::Unix {
  use Regex;
  use StringList;
  use Array;
  
  our $DRIVE_RX_STRING : private string;
  our $UNC_RX_STRING : private string;
  our $VOL_RX_STRING : private string;

  INIT {
    $DRIVE_RX_STRING = "[a-zA-Z]:";
    $UNC_RX_STRING = "(?:\\\\\\\\|//)[^\\\\/]+[\\\\/][^\\\\/]+";
    $VOL_RX_STRING = "(?:$DRIVE_RX_STRING|$UNC_RX_STRING)";
  }

  static method new : File::Spec::Win32 () {
    
    my $self = new File::Spec::Win32;
    
    return $self;
  }
  
  method devnull : string () {
    return "nul";
  }
  
  method rootdir : string () {
    return "\\";
  }

  method tmpdir : string () {
    my $env_tmpdir = Sys->getenv("TMPDIR");
    my $env_temp = Sys->getenv("TEMP");
    my $env_tmp = Sys->getenv("TMP");
    my $dirlist = [
      $env_tmpdir,
      $env_temp,
      $env_tmp,
      "SYS:/temp",
      "C:\system\temp",
      "C:/temp",
      "/tmp",
      "/",
    ];

    my $tmpdir = $self->_tmpdir($dirlist);
    return $tmpdir;
  }
  
  method file_name_is_absolute : int ($path : string) {
    
    my $is_abs = 0;
    my $vol_re = Regex->new("^($VOL_RX_STRING)");
    if ($vol_re->match($path)) {
      my $vol = $vol_re->cap1;
      
      my $unc_re = Regex->new("^$UNC_RX_STRING");
      if ($unc_re->match($vol)) {
        $is_abs = 2;
      }
      else {
        my $drive_re = Regex->new("^$DRIVE_RX_STRING[\\\\/]");
        if ($drive_re->match($path)) {
          $is_abs = 2;
        }
      }
    }
    else {
      my $re = Regex->new("^[\\\\/]");
      my $is_abs = 0;
      if ($re->match($path)) {
        $is_abs = 1;
      }
    }
    
    return $is_abs;
  }

  method _same : int ($path1 : string, $path2 : string) {
    my $same = 0;
    if (Fn->lc($path1) eq Fn->lc($path2)) {
      $same = 1;
    }
    return $same;
  }
  
  method path : string[] () {
    
    my $env_path = Sys->getenv("PATH");
    unless ($env_path) {
      return new string[0];
    }
    
    my $pathes = File::Spec::Unix->compatible_split(";", $env_path);
    
    my $re = Regex->new("\"");
    my $pathes_list = StringList->new;
    for (my $i = 0; $i < @$pathes; $i++) {
      my $path = $pathes->[$i];
      $path = $re->replace_g($path, "");
      if (length $path) {
        $pathes_list->push($path);
      }
    }
    $pathes_list->unshift(".");
    $pathes = $pathes_list->to_array;
    
    return $pathes;
  }
  
  method splitpath : string[] ($path : string, $nofile = 0 : int) {
    
    my $volume = "";
    my $directory = "";
    my $file = "";
    
    if ( $nofile ) {
      my $re = Regex->new("^($VOL_RX_STRING?)(.*)", "s");
      if ($re->match($path)) {
        $volume = $re->cap1;
        $directory = $re->cap2;
      }
    }
    else {
      my $re = Regex->new("^($VOL_RX_STRING?)((?:.*[\\\\/](?:\.\.?\Z(?!\n))?)?)(.*)", "s");
      if ($re->match($path)) {
        $volume    = $re->cap1;
        $directory = $re->cap2;
        $file      = $re->cap3;
      }
    }
    
    return [$volume, $directory, $file];
  }

  method splitdir : string[] ($path : string) {
    if (!Regex->new("[\\\\/]\Z(?!\n)")->match($path)) {
      return Regex->new("[\\\\/]")->split($path);
    }
    else {
      my $dirs = Regex->new("[\\\\/]")->split("${path}dummy");
      $dirs->[@$dirs - 1] = "";
      return $dirs;
    }
  }

  private method _canon_cat : string ($parts : string[]) {
    my $first = $parts->[0];
    
    my $volume = (string)undef;
    
    # drive letter - (C:)
    my $re_drive = Regex->new("\A([A-Za-z]:)([\\\\/]?)");
    if ($first = $re_drive->replace($first, "")) {
      $volume = Fn->ucfirst($re_drive->cap1);
      if ($re_drive->cap2) {
        $volume .= "\\";
      }
    }
    else {
      my $re_unc = Regex->new("\A(?:\\\\\\\\|//)([^\\\\/]+)(?:[\\\\/]([^\\\\/]+))?[\\\\/]?", "s");
      # UNC volume (\\192.168.201.101)
      if ($first = $re_unc->replace($first, "")) {
        $volume = "\\\\" . $re_unc->cap1;
        if ($re_unc->cap2) {
          $volume .= "\\" . $re_unc->cap2;
        }
        $volume .= "\\";
      }
      else {
        my $re_root = Regex->new("\A[\\\\/]");
        # root dir (\foo)
        if ($first = $re_root->replace($first, "")) {
          $volume = "\\";
        }
        else {
          $volume = "";
        }
      }
    }
    
    $parts->[0] = $first;
    
    my $path = Fn->join("\\", $parts);
    
    # /+ to \
    $path = Regex->new("/+")->replace_g($path, "\\");
    
    # \+ to \
    $path = Regex->new("\\\\+")->replace_g($path, "\\");
    
    # xx\.\.\yy --> xx\yy
    $path = Regex->new("(?:(?:\A|\\\\)\.(?:\\\\\.)*(?:\\\\|\z))+")->replace_g($path, "\\");
    
    # xx\yy\..\zz --> xx\zz
    my $parts_list = StringList->new;
    $parts = Fn->split("\\", $path);
    for (my $i = 0; $i < @$parts; $i++) {
      if ($i + 1 < @$parts) {
        my $next_part = $parts->[$i + 1];
        if ($next_part eq "..") {
          $i++;
          next;
        }
      }
      $parts_list->push($parts->[$i]);
    }
    $parts = $parts_list->to_array;
    
    # \xx --> xx
    $path = Regex->new("\A\\\\")->replace_g($path, "");
    
    # xx\ --> xx
    $path = Regex->new("\\\\\z")->replace_g($path, "");
    
    if (Regex->new("\\\\\z")->match($volume)) {
      
      # <vol>\.. --> <vol>\
      $path = Regex->new("\A\.\.(?:\\\\\.\.)*(?:\\\\|\z)")->replace($path, "");
      
      # \\HOST\SHARE\ --> \\HOST\SHARE
      my $re = Regex->new("\A(\\\\.*)\\\z", "s");
      if (length $path && $re->match($path)) {
        $path = $re->cap1;
        return $path;
      }
    }
    
    if (length $path || length $volume) {
      $path = $volume . $path;
    }
    else {
      $path = ".";
    }
    
    return $path;
  }
}
