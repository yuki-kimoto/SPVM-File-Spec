class File::Spec::Unix extends File::Spec {
  use Regex;
  use StringList;
  
  static method new : File::Spec::Unix () {
    
    my $self = new File::Spec::Unix;
    
    return $self;
  }

  method devnull : string () {
    return "/dev/null";
  }
  
  method rootdir : string () {
    return "/";
  }
  
  method curdir : string () {
    return ".";
  }

  method updir : string () {
    return "..";
  }

  method case_tolerant : int () {
    return 0;
  }

  method canonpath : string ($path : string) {
    unless ($path) {
      die "The \$path must be defined";
    }
    
    # xx////xx  -> xx/xx
    $path = Regex->new("/{2,}")->replace_g($path, "/");
    
    # xx/././xx -> xx/xx
    $path = Regex->new("(?:/\.)+(?:/|\z)")->replace_g($path, "/");
    
    # ./xx      -> xx
    unless ($path eq "./") {
      $path = Regex->new("(?s)^(?:\./)+")->replace_g($path, "");
    }
    
    # /../../xx -> xx
    $path = Regex->new("^/(?:\.\./)+")->replace($path, "/");
    
    # /..       -> /
    $path = Regex->new("^/\.\.$")->replace($path, "/");
    
    # xx/       -> xx
    unless ($path eq "/") {
      $path = Regex->new("/\z")->replace($path, "");
    }
    
    return $path;
  }

  method catdir : string ($directories : string[]) {
    my $path = Fn->join("/", $directories);
    $path .= "/";
    
    my $canonpath = $self->canonpath($path);
    
    return $canonpath;
  }

  method catfile : string ($directories : string[], $filename : string) {
    
    my $file = $self->canonpath($filename);
    
    unless ($directories) {
      return $file;
    }
    
    my $dir = $self->catdir($directories);
    my $dir_length = length $dir;
    
    unless ($dir_length >= 1 && $dir->[$dir_length - 1] == '/') {
      $dir .= "/";
    }
    
    my $dir_file = $dir . $file;
    
    return $dir_file;    
  }


  method no_upwards : string[] ($directories : string[]) {
    my $no_upwards_list = StringList->new;
    
    my $re = Regex->new("(?s)^\.{1,2}\z");
    for my $dir (@$directories) {
      unless ($re->match($dir)) {
        $no_upwards_list->push($dir);
      }
    }
    
    my $no_upwards = $no_upwards_list->to_array;
    
    return $no_upwards;
  }
  
  method file_name_is_absolute : int ($path : string) {
    my $re = Regex->new("(?s)^/");
    my $is_abs = 0;
    if ($re->match($path)) {
      $is_abs = 1;
    }
    return $is_abs;
  }
  
  method join : string ($directories : string[], $filename : string) {
    return $self->catfile($directories, $filename);
  }
  
  method catpath : string ($volume : string, $directory : string, $file : string) {
    unless ($directory) {
      die "The \$directory must be defined";
    }
    unless ($file) {
      die "The \$file must be defined";
    }
    
    my $directory_length = length $directory;
    my $file_length = length $file;
    if ( $directory ne ""                && 
         $file ne ""                     && 
         $directory->[$directory_length - 1] != '/' && 
         $file->[0] != '/')
    {
      $directory .= "/$file" ;
    }
    else {
      $directory .= $file ;
    }
    
    return $directory;
  }

  method splitpath : string[] ($path : string, $no_file = 0 : int) {
    
    my $volume = "";
    my $directory = "";
    my $file = "";
    
    if ( $no_file ) {
      $directory = $path;
    }
    else {
      my $re = Regex->new("(?s)^((?:.*/(?:\.\.?\z)?)?)([^/]*)");
      if ($re->match($path)) {
        $directory = $re->cap1;
        $file      = $re->cap2;
      }
    }
    
    return [$volume, $directory, $file];
  }
  
=pod TODO
  
  method splitdir : string[] ($directories : string[]);
  method abs2rel : string ($path : string, $base : string);
  
  method rel2abs : string ($path : string, $base : string);
  
  method tmpdir : string ();
  
  method path : string[] ();
  
=cut

}
