class File::Spec::Unix extends File::Spec {
  use Regex;
  use StringList;
  use Cwd;
  
  static method new : File::Spec::Unix () {
    
    my $self = new File::Spec::Unix;
    
    return $self;
  }

  method devnull : string () {
    return "/dev/null";
  }
  
  method rootdir : string () {
    return "/";
  }
  
  method curdir : string () {
    return ".";
  }

  method updir : string () {
    return "..";
  }

  method case_tolerant : int () {
    return 0;
  }

  method canonpath : string ($path : string) {
    unless ($path) {
      die "The \$path must be defined";
    }
    
    # xx////xx  -> xx/xx
    $path = Regex->new("/{2,}")->replace_g($path, "/");
    
    # xx/././xx -> xx/xx
    $path = Regex->new("(?:/\.)+(?:/|\z)")->replace_g($path, "/");
    
    # ./xx      -> xx
    unless ($path eq "./") {
      $path = Regex->new("(?s)^(?:\./)+")->replace_g($path, "");
    }
    
    # /../../xx -> xx
    $path = Regex->new("^/(?:\.\./)+")->replace($path, "/");
    
    # /..       -> /
    $path = Regex->new("^/\.\.$")->replace($path, "/");
    
    # xx/       -> xx
    unless ($path eq "/") {
      $path = Regex->new("/\z")->replace($path, "");
    }
    
    return $path;
  }

  method catdir : string ($directories : string[]) {
    my $path = Fn->join("/", $directories);
    $path .= "/";
    
    my $canonpath = $self->canonpath($path);
    
    return $canonpath;
  }

  method catfile : string ($directories : string[], $filename : string) {
    
    my $file = $self->canonpath($filename);
    
    unless ($directories) {
      return $file;
    }
    
    my $dir = $self->catdir($directories);
    my $dir_length = length $dir;
    
    unless ($dir_length >= 1 && $dir->[$dir_length - 1] == '/') {
      $dir .= "/";
    }
    
    my $dir_file = $dir . $file;
    
    return $dir_file;    
  }


  method no_upwards : string[] ($directories : string[]) {
    my $no_upwards_list = StringList->new;
    
    my $re = Regex->new("(?s)^\.{1,2}\z");
    for my $dir (@$directories) {
      unless ($re->match($dir)) {
        $no_upwards_list->push($dir);
      }
    }
    
    my $no_upwards = $no_upwards_list->to_array;
    
    return $no_upwards;
  }
  
  method file_name_is_absolute : int ($path : string) {
    my $re = Regex->new("(?s)^/");
    my $is_abs = 0;
    if ($re->match($path)) {
      $is_abs = 1;
    }
    return $is_abs;
  }
  
  method join : string ($directories : string[], $filename : string) {
    return $self->catfile($directories, $filename);
  }
  
  method catpath : string ($volume : string, $directory : string, $file : string) {
    unless ($directory) {
      die "The \$directory must be defined";
    }
    unless ($file) {
      die "The \$file must be defined";
    }
    
    my $directory_length = length $directory;
    my $file_length = length $file;
    if ( $directory ne ""                && 
         $file ne ""                     && 
         $directory->[$directory_length - 1] != '/' && 
         $file->[0] != '/')
    {
      $directory .= "/$file" ;
    }
    else {
      $directory .= $file ;
    }
    
    return $directory;
  }

  method splitpath : string[] ($path : string, $no_file = 0 : int) {
    
    my $volume = "";
    my $directory = "";
    my $file = "";
    
    if ( $no_file ) {
      $directory = $path;
    }
    else {
      my $re = Regex->new("(?s)^((?:.*/(?:\.\.?\z)?)?)([^/]*)");
      if ($re->match($path)) {
        $directory = $re->cap1;
        $file      = $re->cap2;
      }
    }
    
    return [$volume, $directory, $file];
  }

  method rel2abs : string ($path : string, $base = undef : string) {
    
    # Clean up $path
    if (!$self->file_name_is_absolute($path)) {
      # Figure out the effective $base and clean it up.
      if (!$base || $base eq "") {
        $base = Cwd->getcwd;
      }
      elsif (!$self->file_name_is_absolute($base)) {
        $base = $self->rel2abs($base) ;
      }
      else {
        $base = $self->canonpath($base);
      }
      # Glom them together
      $path = $self->catdir([$base, $path]);
    }
    
    my $rel2abs = $self->canonpath($path);
    
    return $rel2abs;
  }
  
  private static method re_split : string[] ($re_separator : Regex, $string : string, $limit = -1 : int) {
    unless ($re_separator) {
      die "The \$separator must be defined";
    }
    
    unless ($string) {
      die "The \$string must be defined";
    }
    
    my $string_length = length $string;
    
    if ($limit == 0) {
      die "The \$limit can't be 0";
    }
    
    my $separated_strings_list = StringList->new_len(0);
    
    my $string_base = 0;
    my $match_count = 0;
    while (1) {
      if ($limit > 0 && $match_count >= $limit - 1) {
        last;
      }
      
      my $before_string_base = $string_base;
      my $match = $re_separator->match_forward($string, \$string_base);
      if ($match) {
        $match_count++;
        
        my $separated_string = Fn->substr($string, $before_string_base, $string_base - $before_string_base);
        $separated_strings_list->push($separated_string);
      }
      else {
        last;
      }
    }
    if ($string_base == $string_length) {
      $separated_strings_list->push("");
    }
    else {
      my $separated_string = Fn->substr($string, $string_base, $string_length - $string_base);
      $separated_strings_list->push($separated_string);
    }
    
    my $separated_strings = $separated_strings_list->to_array;
    
    return $separated_strings;
  }
  
=pod TODO
  
  method splitdir : string[] ($directories : string[]);
  method abs2rel : string ($path : string, $base : string);
  method tmpdir : string ();
  
  method path : string[] ();
  
=cut

}
